# Шаг 3.2.6

""" Как можно проверить ожидаемый результат? Для этого используется встроенная в Python инструкция assert, 
которая проверяет истинность утверждений. assert True не приводит к выводу дополнительных сообщений, 
а вот assert False вызовет исключение AssertionError.

Рассмотрим работу assert на примере встроенной функции abs(), которая возвращает абсолютное значение числа по модулю """

# Если значение выражения истинно, то в консоли не должно появиться дополнительных сообщений. Выполним:
assert abs(-42) == 42

# Если условие не выполнено, то в консоли выводится лог ошибки с названием файла и номером строчки, в которой произошла ошибка, а также тип ошибки AssertionError:
assert abs(-42) == -42

""" Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

AssertionError """

""" Простое сообщение AssertionError не очень информативно. Когда тестов становится много, бывает сложно вспомнить, 
что именно мы проверяем в данном тесте. Для добавления дополнительного сообщения можно при вызове assert через запятую 
написать нужное сообщение, которое будет выведено в случае ошибки проверки результата: """

assert abs(-42) == -42, "Should be absolute value of a number"

""" Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

AssertionError: Should be absolute value of a number """

# Шаг 3.2.7

""" Составные сообщения об ошибках.

Отдельно хочется поговорить про качество сообщений об ошибках, которые показываются при падении теста. 
Почему это важно? Хорошо написанный текст помогает быстро локализовать найденный баг и разобраться в том, 
что произошло и из-за чего тест упал. Хороший assert сэкономит вам часы вашей работы, особенно когда количество тестов переходит за сотню.

В целом, тут как с любым фидбеком: важно давать его точно и актуально. Если вы проверяете наличие элемента, 
то обязательно пишите, что это за элемент по смыслу на странице: """
assert self.is_element_present('create_class_button', timeout=30), "No create class button"

""" Если элемент встречается на нескольких страницах приложения, не лишним будет указать, где именно произошла ошибка: """
assert self.is_element_present('new_announcement_button', timeout=30), "No new announcement button on profile page"

""" Если вы работаете с каким-то текстом (например, проверяете информационное сообщение, текущий url, ссылку, 
placeholder в input-элементе или любой другой текст), 
в сообщении об ошибке всегда лучше выводить оба значения: то, которое ожидалось, 
и то, которое получили по факту. Всё как в хорошем багрепорте: ожидаемый и фактический результат. """

""" Форматирование строк с помощью конкатенации.

В питоне такое можно провернуть с помощью конкатенации строк, например: """
actual_result = "abrakadabra"
print("Wrong text, got " + actual_result + ", something wrong")
""" Но из-за обилия кавычек, знаков сложения и вот этого всего этот способ не самый удобный и читается тоже плохо. """

""" Форматирование строк с помощью str.format.

Гораздо лучше воспользоваться возможностью python для форматирования строк. 
Дополнительно можно почитать здесь: https://realpython.com/python-string-formatting/#2-new-style-string-formatting-strformat

Если вкратце, то python умеет подставлять пользовательские значения в строки с помощью функции .format(). 
Синтаксис выглядит примерно так: """

"Let's count together: {}, then goes {}, and then {}".format("one", "two", "three")

# Попробуйте запустить её в интерпретаторе:
print("Let's count together: {}, then goes {}, and then {}".format("one", "two", "three"))

""" Такая строка при исполнении кода превратится в: Let's count together: one, then goes two, and then three
Таким образом мы можем удобно компоновать ожидаемое и фактическое значение в одну строку. """

""" Форматирование строк с помощью f-strings.

И наконец наиболее современный способ форматирования строк, который появился в Python3.6, носит название f-strings. 
Он позволяет исполнять выражения на Python прямо внутри строк, обладает еще большей лаконичностью и удобством использования. 
Для использования возможностей f-strings нужно указывать символ f перед строкой в таком формате: f"ваша строка {my_var}". 
В фигурных скобках указывается имя переменной, значение которой надо подставить в строку, или выражение, 
результат исполнения которого также требуется подставить в вашу строку.
Подробнее про f-strings можно почитать здесь: https://realpython.com/python-string-formatting/#3-string-interpolation-f-strings-python-36. """

# Пример 1:
str1 = "one"
str2 = "two"
str3 = "three"
print(f"Let's count together: {str1}, then goes {str2}, and then {str3}")

""" Итог выполнения выражений в интерпретаторе: Let's count together: one, then goes two, and then three """
# Пример 2:
actual_result = "abrakadabra"
f"Wrong text, got {actual_result}, something wrong"

""" Итог выполнения выражений в интерпретаторе: Wrong text, got abrakadabra, something wrong """

# Пример 3:
f"{2+3}"
""" Итог выполнения выражений в интерпретаторе:'5' """
 
""" Еще один важный момент: когда вы работаете с текстом элементов на странице или любым другим контентом, 
который может измениться, всегда записывайте его в отдельную переменную для сравнения.  """

# неправильно: 
assert self.catalog_link.text  == "Каталог", \
    f"Wrong language, got {self.catalog_link.text} instead of 'Каталог'" 

""" Дважды считывать атрибут — это плохая практика, потому что при повторном считывании текст на странице может измениться, 
и вы получите неактуальный текст об ошибке. Результат выполнения такого теста сложно анализировать: "Wrong language, got 'Каталог' instead of 'Каталог'" """

# правильно: 
catalog_text = self.catalog_link.text # считываем текст и записываем его в переменную
assert catalog_text == "Каталог", \
    f"Wrong language, got {catalog_text} instead of 'Каталог'" 

expected_result = 11
actual_result = 15
def test_input_text(expected_result, actual_result):
    assert expected_result == actual_result, \
        f"expected {expected_result}, got {actual_result}"
    
""" Иногда при работе с текстами не нужны жёсткие проверки на полное совпадение, 
и требуется проверить, что некий текст является подстрокой другого текста. 
Это можно сделать либо с помощью ключевого слова in, либо с помощью функции find: """

s = 'My Name is Julia'

if 'Name' in s:
    print('Substring found')

index = s.find('Name')
if index != -1:
    print(f'Substring found at index {index}')

""" Попробуйте запустить этот код в интерпретаторе, чтобы понять разницу в подходах.

Конструкция 'Name' in s возвращает просто True или False, a find() возвращает индекс первого вхождения подстроки в строку 
и -1, если подстрока не найдена. Обычно в автотестах достаточно использовать in, потому что это более читабельный вариант. """

# Например, для проверки того, что в текущем url содержится строка login: 
assert "login" in browser.current_url, 'сообщение об ошибке'

def test_substring(full_string, substring):
    assert substring in full_string, \
        f"expected {substring} to be substring of {full_string}"