# Шаг 3.2.6

""" Как можно проверить ожидаемый результат? Для этого используется встроенная в Python инструкция assert, 
которая проверяет истинность утверждений. assert True не приводит к выводу дополнительных сообщений, 
а вот assert False вызовет исключение AssertionError.

Рассмотрим работу assert на примере встроенной функции abs(), которая возвращает абсолютное значение числа по модулю """

# Если значение выражения истинно, то в консоли не должно появиться дополнительных сообщений. Выполним:
assert abs(-42) == 42

# Если условие не выполнено, то в консоли выводится лог ошибки с названием файла и номером строчки, в которой произошла ошибка, а также тип ошибки AssertionError:
assert abs(-42) == -42

""" Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

AssertionError """

""" Простое сообщение AssertionError не очень информативно. Когда тестов становится много, бывает сложно вспомнить, 
что именно мы проверяем в данном тесте. Для добавления дополнительного сообщения можно при вызове assert через запятую 
написать нужное сообщение, которое будет выведено в случае ошибки проверки результата: """

assert abs(-42) == -42, "Should be absolute value of a number"

""" Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

AssertionError: Should be absolute value of a number """

# Шаг 3.2.7

""" Составные сообщения об ошибках.

Отдельно хочется поговорить про качество сообщений об ошибках, которые показываются при падении теста. 
Почему это важно? Хорошо написанный текст помогает быстро локализовать найденный баг и разобраться в том, 
что произошло и из-за чего тест упал. Хороший assert сэкономит вам часы вашей работы, особенно когда количество тестов переходит за сотню.

В целом, тут как с любым фидбеком: важно давать его точно и актуально. Если вы проверяете наличие элемента, 
то обязательно пишите, что это за элемент по смыслу на странице: """
assert self.is_element_present('create_class_button', timeout=30), "No create class button"

""" Если элемент встречается на нескольких страницах приложения, не лишним будет указать, где именно произошла ошибка: """
assert self.is_element_present('new_announcement_button', timeout=30), "No new announcement button on profile page"

""" Если вы работаете с каким-то текстом (например, проверяете информационное сообщение, текущий url, ссылку, 
placeholder в input-элементе или любой другой текст), 
в сообщении об ошибке всегда лучше выводить оба значения: то, которое ожидалось, 
и то, которое получили по факту. Всё как в хорошем багрепорте: ожидаемый и фактический результат. """

""" Форматирование строк с помощью конкатенации.

В питоне такое можно провернуть с помощью конкатенации строк, например: """
actual_result = "abrakadabra"
print("Wrong text, got " + actual_result + ", something wrong")
""" Но из-за обилия кавычек, знаков сложения и вот этого всего этот способ не самый удобный и читается тоже плохо. """

""" Форматирование строк с помощью str.format.

Гораздо лучше воспользоваться возможностью python для форматирования строк. 
Дополнительно можно почитать здесь: https://realpython.com/python-string-formatting/#2-new-style-string-formatting-strformat

Если вкратце, то python умеет подставлять пользовательские значения в строки с помощью функции .format(). 
Синтаксис выглядит примерно так: """

"Let's count together: {}, then goes {}, and then {}".format("one", "two", "three")

# Попробуйте запустить её в интерпретаторе:
print("Let's count together: {}, then goes {}, and then {}".format("one", "two", "three"))

""" Такая строка при исполнении кода превратится в: Let's count together: one, then goes two, and then three
Таким образом мы можем удобно компоновать ожидаемое и фактическое значение в одну строку. """

""" Форматирование строк с помощью f-strings.

И наконец наиболее современный способ форматирования строк, который появился в Python3.6, носит название f-strings. 
Он позволяет исполнять выражения на Python прямо внутри строк, обладает еще большей лаконичностью и удобством использования. 
Для использования возможностей f-strings нужно указывать символ f перед строкой в таком формате: f"ваша строка {my_var}". 
В фигурных скобках указывается имя переменной, значение которой надо подставить в строку, или выражение, 
результат исполнения которого также требуется подставить в вашу строку.
Подробнее про f-strings можно почитать здесь: https://realpython.com/python-string-formatting/#3-string-interpolation-f-strings-python-36. """

# Пример 1:
str1 = "one"
str2 = "two"
str3 = "three"
print(f"Let's count together: {str1}, then goes {str2}, and then {str3}")

""" Итог выполнения выражений в интерпретаторе: Let's count together: one, then goes two, and then three """
# Пример 2:
actual_result = "abrakadabra"
f"Wrong text, got {actual_result}, something wrong"

""" Итог выполнения выражений в интерпретаторе: Wrong text, got abrakadabra, something wrong """

# Пример 3:
f"{2+3}"
""" Итог выполнения выражений в интерпретаторе:'5' """
 
""" Еще один важный момент: когда вы работаете с текстом элементов на странице или любым другим контентом, 
который может измениться, всегда записывайте его в отдельную переменную для сравнения.  """

# неправильно: 
assert self.catalog_link.text  == "Каталог", \
    f"Wrong language, got {self.catalog_link.text} instead of 'Каталог'" 

""" Дважды считывать атрибут — это плохая практика, потому что при повторном считывании текст на странице может измениться, 
и вы получите неактуальный текст об ошибке. Результат выполнения такого теста сложно анализировать: "Wrong language, got 'Каталог' instead of 'Каталог'" """

# правильно: 
catalog_text = self.catalog_link.text # считываем текст и записываем его в переменную
assert catalog_text == "Каталог", \
    f"Wrong language, got {catalog_text} instead of 'Каталог'" 

# Шаг 3.2.9
    
""" Иногда при работе с текстами не нужны жёсткие проверки на полное совпадение, 
и требуется проверить, что некий текст является подстрокой другого текста. 
Это можно сделать либо с помощью ключевого слова in, либо с помощью функции find: """

s = 'My Name is Julia'

if 'Name' in s:
    print('Substring found')

index = s.find('Name')
if index != -1:
    print(f'Substring found at index {index}')

""" Попробуйте запустить этот код в интерпретаторе, чтобы понять разницу в подходах.

Конструкция 'Name' in s возвращает просто True или False, a find() возвращает индекс первого вхождения подстроки в строку 
и -1, если подстрока не найдена. Обычно в автотестах достаточно использовать in, потому что это более читабельный вариант. """

# Например, для проверки того, что в текущем url содержится строка login: 
assert "login" in browser.current_url, 'сообщение об ошибке'

# Шаг 3.2.10

""" Тестовые сценарии.

Созданные тесты нужно сохранить в файле, чтобы его было удобно запускать и хранить в системе контроля версий. 
Создадим файл test_abs_project.py и напишем в нём следующий код: """

def test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number" 

if __name__ == "__main__":
    test_abs1()
    print("All tests passed!")

""" Мы поместили тестовый сценарий в функцию для разделения тест-кейсов и возможности их независимого запуска.

Не вдаваясь в подробности, скажем только, что конструкция if __name__ == "__main__" служит для подтверждения того, 
что данный скрипт был запущен напрямую, а не вызван внутри другого файла в качестве модуля. 
Весь код написанный в теле этого условия будет выполнен только если пользователь запустил файл самостоятельно.

В этой конструкции мы вызвали функцию test_abs1(), которая выполняет тестовый сценарий.

С помощью print("All tests passed!") мы вывели сообщение, если все тесты прошли успешно.

Вы должны увидеть в консоли сообщение "All tests passed!".

Если нам нужно добавить еще один тест, мы можем написать его как функцию в этом же файле. 
В приведенном примере мы уже не увидим сообщение "Everything passed", 
так как падение любого теста вызывает выход из программы: """

def test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number"

def test_abs2():
    assert abs(-42) == -42, "Should be absolute value of a number"

if __name__ == "__main__":
    test_abs1()
    test_abs2()
    print("Everything passed")

""" Запустите файл снова. Вы должны увидеть сообщение об упавшем втором тесте:

$ python test_abs_project.py

Traceback (most recent call last):

  File "test_abs_project.py", line 9, in <module>

    test_abs2()

  File "test_abs_project.py", line 5, in test_abs2

    assert abs(-42) == -42, "Should be absolute value of a number"

AssertionError: Should be absolute value of a number """

# Шаг 3.2.11

""" Выбор test runner.

Рассмотрим минусы подхода к запуску автотестов из шага 3.2.10:

Когда тестов становится много, сложно становится запускать только тесты из нужных тест-сьютов.
Для каждого теста нужно создавать тестовые данные и окружение отдельно. 
Например, если мы захотим для каждого теста запускать браузер, а после завершения теста браузер закрывать, 
то логику работы с браузером придется дублировать в коде каждого теста.
Если один из тестов завершится с ошибкой, например, тест упадёт с ошибкой AssertionError, 
то последующие тесты не запустятся. Мы не узнаем, были ли проблемы в этих тестах, 
пока не починим упавший тест или пока не запустим эти тесты по отдельности.
Для решения этих проблем и упрощения написания и запуска тестов существуют специальные фреймворки, 
которые называются test runners (тест-раннеры). 
Можно выделить три основных тестовых фреймворка для Python: unittest, PyTest и nose. 
Модуль unittest является встроенным инструментом Python — и это его большой плюс. 
PyTest и nose устанавливаются дополнительно, они позволяют получить расширенные возможности по сравнению с unittest. 
Мы кратко рассмотрим, как используется unittest, а затем изучим возможности PyTest, 
который позволяет писать более простой код тестов по сравнению с unittest и гибко настраивать запуск тестов. 
Еще один плюс использования PyTest в том, что для него существует большое количество плагинов, 
которые позволяют решить практически любую проблему, связанную с запуском автотестов. """

# Шаг 3.2.12

""" unittest.

Тест-раннеры сами находят тестовые методы в указанных при запуске файлах, но для этого нужно следовать общепринятым правилам. 
Общее правило для всех фреймворков: название тестового метода должно начинаться со слова "test_".  
Дальше может идти любой текст, который является уникальным названием для теста: """

def test_name_for_your_test():
    # содержимое метода

 """ Для unittest существуют собственные дополнительные правила:

- Тесты обязательно должны находиться в специальном тестовом классе.
- Вместо assert должны использоваться специальные assertion методы.

Давайте теперь изменим наши предыдущие тесты, чтобы их можно было запустить с помощью unittest. 
Для этого нам понадобится выполнить следующие шаги:

1. Импортировать unittest в файл: import unittest
2. Создать класс, который должен наследоваться от класса TestCase: class TestAbs(unittest.TestCase):
3. Превратить тестовые функции в методы, добавив ссылку на экземпляр класса self в качестве первого аргумента функции: def test_abs1(self):
4. Изменить assert на self.assertEqual()
5. Заменить строку запуска программы на unittest.main() """

import unittest

class TestAbs(unittest.TestCase):
    def test_abs1(self):
        self.assertEqual(abs(-42), 42, "Should be absolute value of a number")
        
    def test_abs2(self):
        self.assertEqual(abs(-42), -42, "Should be absolute value of a number")
        
if __name__ == "__main__":
    unittest.main()

""" После изменений запустим наш файл с тестами всё так же с помощью Python:

python test_abs_project.py

.F

======================================================================

FAIL: test_abs2 (__main__.TestAbs)

----------------------------------------------------------------------

Traceback (most recent call last):

  File "test_abs_project.py", line 9, in test_abs2

    self.assertEqual(abs(-42), -42, "Should be absolute value of a number")

AssertionError: Should be absolute value of a number

----------------------------------------------------------------------

Ran 2 tests in 0.000s

FAILED (failures=1)

Теперь мы видим более подробную информацию о результатах запуска: 
было запущено два теста, один тест выполнился с ошибкой. Место ошибки и пояснение к ней отображаются в логе.

В следующем уроке мы рассмотрим преимущества и особенности использования тестового фреймворка PyTest """