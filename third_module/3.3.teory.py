# шаг 3.3.2

""" PyTest — преимущества и недостатки.

Рассмотрим преимущества использования PyTest:

1) PyTest полностью обратно совместим с фреймворками unittest и nosetest. 
Это означает, что если изначально вы писали тесты, используя unittest, 
то перейти на PyTest можно буквально в ту же минуту. 
Для этого в вашем виртуальном окружении должен быть установлен пакет PyTest. 
Не забудьте активировать ваше виртуальное окружение и установите PyTest.

Для Windows:

> selenium_env\Scripts\activate.bat 
(selenium_env) С:\Users\user\environments>  pip install pytest==7.1.2

Теперь мы можем запустить тесты в нашем файле test_abs_project.py с помощью PyTest, не изменяя сам файл. 
PyTest сам найдёт тесты в папке, в которой вы их запускаете, и выполнит их:

pytest test_abs_project.py

2) Подробный отчёт с поддержкой цветовых схем из коробки.

3) PyTest не требует написания дополнительных специфических конструкций в тестах, как того требует unittest (no boilerplate).

4) Для проверок используется стандартный assert из Python.

5) Возможность создания динамических фикстур (специальных функций, которые настраивают тестовые окружения и готовят тестовые данные).

6) Дополнительные возможности по настройке фикстур.

7) Параметризация тестов — для одного теста можно задать разные параметры (тест запустится несколько раз с разными тестовыми данными).

8) Наличие маркировок (marks), которые позволяют маркировать тесты для их выборочного запуска.

9) Возможность передавать дополнительные параметры через командную строку для настройки тестовых окружений.

10) Большое количество плагинов, которые расширяют возможности PyTest и позволяют решать узкоспециализированные проблемы, что может сэкономить много времени.

Рассмотрим минусы PyTest:

1) PyTest требуется устанавливать дополнительно, так как он не входит в стандартный пакет библиотек Python, в отличие от unittest. 
Нужно не забывать об этом, когда вы будете настраивать автоматический запуск тестов с помощью CI-сервера.

2) Использование PyTest требует более глубокого понимания языка Python, чтобы разобраться, 
как применять фикстуры, параметризацию и другие возможности PyTest. """

# шаг 3.3.4

""" Фиксируем пакеты в requirements.txt.

Количество пакетов в нашем проекте растет, а мы тем временем все дальше уходим от учебных кусочков скриптов 
в сторону настоящего тестового проекта, поэтому в этом шаге давайте зафиксируем все пакеты, которые мы используем. 
Это стандартная практика, которая позволяет быстро переключаться в свежее виртуальное окружение, 
а также работать нескольким людям над одним проектом, получая одинаковые результаты.

Откройте терминал, перейдите в директорию, в которой вы работаете с автотестами, и активируйте виртуальное окружение.

После чего выполните в терминале команду:

pip freeze > requirements.txt
Эта команда сохранит все версии пакетов в специальный файл requirements.txt.

Как их оттуда достать? Попробуйте создать новое виртуальное окружение (если нужно, вернитесь в модуль 1 за инструкциями) и активировать. После чего выполните команду:

pip install -r requirements.txt
В свежем окружении все пакеты установлены одной командой! """

# шаг 3.3.5

""" PyTest: правила запуска тестов/

В этом шаге мы коротко обсудим важные особенности запуска тестов с помощью PyTest. 
Когда мы выполняем команду pytest, тест-раннер собирает все тесты для запуска по определенным правилам:

- если мы не передали никакого аргумента в команду, а написали просто pytest, тест-раннер начнёт поиск в текущей директории

- как аргумент можно передать файл, путь к директории или любую комбинацию директорий и файлов, например: 

pytest scripts/selenium_scripts
# найти все тесты в директории scripts/selenium_scripts

pytest test_user_interface.py
# найти и выполнить все тесты в файле 

pytest scripts/drafts.py::test_register_new_user_parametrized
# найти тест с именем test_register_new_user_parametrized в указанном файле в указанной директории и выполнить 

- дальше происходит рекурсивный поиск: то есть PyTest обойдет все вложенные директории

- во всех директориях PyTest ищет файлы, которые удовлетворяют правилу  test_*.py или *_test.py 
(то есть начинаются на test_ или заканчиваются _test и имеют расширение .py)

- внутри всех этих файлов находит тестовые функции по следующему правилу:

- все тесты, название которых начинается с test, которые находятся вне классов

- все тесты, название которых начинается с test внутри классов, имя которых начинается с Test (и без метода __init__ внутри класса) """

# шаг 3.3.7

""" PyTest — отчёты.

Вы могли заметить, что PyTest позволяет генерировать подробный отчёт с поддержкой цветовых схем и форматированием прямо из коробки.

Если еще раз запустим наши тесты с помощью unittest и PyTest, чтобы сравнить выводимый результат, 
увидим, что в PyTest-отчёте упавший тест выделен красным шрифтом, что делает разбор логов более приятным занятием.

Если запустить PyTest с параметром -v (verbose, то есть подробный)

pytest -v test_abs_project.py

то в отчёт добавится дополнительная информация со списком тестов и статусом их прохождения:

collected 2 items                                                                                                                                                                                                  

test_abs_project.py::test_abs1 PASSED                                                                                                                                                                       [ 50%] 
test_abs_project.py::test_abs2 FAILED 
=================== FAILURES =========================
________ test_abs2 ________

    def test_abs2():
>       assert abs(-42) == -42, "Should be absolute value of a number"
E       AssertionError: Should be absolute value of a number
E       assert 42 == -42
E        +  where 42 = abs(-42)

test_abs_project.py:16: AssertionError
============== short test summary info ============
FAILED test_abs_project.py::test_abs2 - AssertionError: Should be absolute value of a number
============== 1 failed, 1 passed in 0.07s ============= 

Список команд:
py.test test_sample.py --collect-only # собирает информацию тестового набора

py.test test_sample.py -v # выводит вербозные сообщения

py.test -q test_sample.py # опустить вывод имени файла

python -m pytest -q test_sample.py # вызов pytest через python

py.test --markers # показать доступные маркеры

# Для того чтобы создать маркер многократного использования.
/*
# содержимое pytest.ini
[pytest].
маркеры =
    webtest: пометить тест как webtest.
*/

py.test -k "TestClass, а не test_one" # запускать только тесты с именами, которые соответствуют "строковому выражению"

py.test test_server.py::TestClass::test_method # cnly run tests that match the node ID

py.test -x # останавливаться после первой неудачи

py.test --maxfail=2 # останавливаться после двух неудач

py.test --showlocals # показывать локальные переменные в трассировках
py.test -l # (сокращение)

py.test --tb=long # информативное форматирование трассировки по умолчанию
py.test --tb=native # форматирование стандартной библиотеки Python
py.test --tb=short # более короткий формат возвратов к трассировке
py.test --tb=line # только одна строка для каждого сбоя
py.test --tb=no # отсутствие вывода трассировки

py.test -x --pdb # при первом сбое сброс в PDB, затем завершение сеанса тестирования

py.test --durations=10 # список 10 самых медленных длительностей теста.

py.test --maxfail=2 -rf # выход после двух сбоев, сообщение о сбое.

py.test -n 4 # посылать тесты на несколько процессоров

py.test -m slowest # запускать тесты с декоратором @pytest.mark.slowest или slowest = pytest.mark.slowest; @slowest

py.test --traceconfig # выяснить, какие плагины py.test активны в вашем окружении.

py.test --instafail # если установлен pytest-instafail, показывать ошибки и сбои мгновенно, а не ждать окончания набора тестов.

# Тестирование с использованием параметризации
/*
    import pytest

    @pytest.mark.parametrize(
        ('n', 'expected'), [
            (1, 2),
            (2, 3),
            (3, 4),
            (4, 5),
            pytest.mark.xfail((1, 0)),
            pytest.mark.xfail(reason="some bug")((1, 0)),
            pytest.mark.skipif('sys.version_info >= (3,0)')((10, 11)),
        ]
    )
    def test_increment(n, expected):
        assert n + 1 == expected
*/ """

# шаг 3.3.8

""" PyTest — как пишут тесты.

PyTest не требует написания дополнительных специфических конструкций в тестах, как того требует unittest.

Мы уже увидели, что PyTest может запускать тесты, написанные в unittest-стиле. 
Перепишем наши тесты из test_abs_project.py в более простом формате, который также понимает PyTest. 
Назовём новый файл test_abs.py: """

def test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number"

def test_abs2():
    assert abs(-42) == -42, "Should be absolute value of a number"

""" Запустим тесты в этом файле:

pytest test_abs.py

Код тестов стал короче и читабельнее. """

# шаг 3.3.9

""" PyTest — проверка ожидаемого результата (assert).

Если вы используете unittest, то для проверки ожидаемых результатов в тестах вам нужно знать 
и использовать большой набор assert-методов, например, таких: 
assertEqual, assertNotEqual, assertTrue, assertFalse и другие.

В PyTest используется стандартный assert метод из языка Python, что делает код более очевидным.

Давайте сравним два подхода. Проверим, что две переменные равны друг другу.

unittest: self.assertEqual(a, b, msg="Значения разные")

PyTest: assert a == b, "Значения разные"

С помощью assert можно проверять любую конструкцию, которая возвращает True/False. 
Это может быть проверка равенства, неравенства, содержания подстроки в строке или 
любая другая вспомогательная функция, которую вы опишете самостоятельно. 
Все это делает код проверок приятным и понятным для чтения: 

assert user_is_authorised(), "User is guest"

Если нужно проверить, что тест вызывает ожидаемое исключение 
(довольно редкая ситуация для UI-тестов, и вам этот способ, скорее всего, никогда не пригодится), 
мы можем использовать специальную конструкцию with pytest.raises(). 
Например, можно проверить, что на странице сайта не должен отображаться какой-то элемент: """

import pytest

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.common.exceptions import NoSuchElementException


def test_exception1():
    try:
        browser = webdriver.Chrome()
        browser.get("http://selenium1py.pythonanywhere.com/")
        with pytest.raises(NoSuchElementException):
            browser.find_element(By.CSS_SELECTOR, "button.btn")
            pytest.fail("Не должно быть кнопки Отправить")
    finally: 
        browser.quit()

def test_exception2():
    try:
        browser = webdriver.Chrome()
        browser.get("http://selenium1py.pythonanywhere.com/")
        with pytest.raises(NoSuchElementException):
            browser.find_element(By.CSS_SELECTOR, "no_such_button.btn")
            pytest.fail("Не должно быть кнопки Отправить")
    finally: 
        browser.quit()
""" В первом тесте элемент будет найден, поэтому ошибка NoSuchElementException, 
которую ожидает контекстный менеджер pytest.raises, не возникнет, и тест упадёт.

test_3_3_9_pytest_raises.py:8 (test_exception1)
E   Failed: Не должно быть кнопки Отправить

Во втором тесте, как мы и ожидали, кнопка не будет найдена, и тест пройдет. """